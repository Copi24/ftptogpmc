name: Google Photos WebDAV Server

on:
  workflow_dispatch:

jobs:
  webdav-server:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours max
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      
      - name: Update GPMC cache
        env:
          GP_AUTH_DATA: ${{ secrets.GP_AUTH_DATA }}
        run: |
          # Create update script
          cat <<EOF > update_cache.py
          from gpmc import Client
          import os
          import sqlite3
          
          print('Initializing client...')
          client = Client(auth_data=os.environ['GP_AUTH_DATA'])
          print(f'Cache path: {client.db_path}')
          
          print('Starting cache update (this may take a while)...')
          # update_cache handles pagination and large libraries automatically
          client.update_cache(show_progress=True)
          print('Cache update completed.')
          
          # Verify and Inspect Schema
          if os.path.exists(client.db_path):
              with sqlite3.connect(client.db_path) as conn:
                  cursor = conn.cursor()
                  
                  # List all tables
                  cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
                  tables = cursor.fetchall()
                  print(f'Tables in DB: {tables}')
                  
                  # Check remote_media count
                  cursor.execute("SELECT COUNT(*) FROM remote_media")
                  count = cursor.fetchone()[0]
                  print(f'Total items in remote_media: {count}')
                  
                  # Inspect albums table if it exists
                  if ('albums',) in tables or ('albums',) in [t[0] for t in tables]: # handle list of tuples
                      print("Found 'albums' table! Inspecting schema...")
                      cursor.execute("PRAGMA table_info(albums)")
                      print(cursor.fetchall())
                      cursor.execute("SELECT * FROM albums LIMIT 5")
                      print(cursor.fetchall())
                  else:
                      print("'albums' table NOT found.")
                      
                  # Inspect remote_media schema
                  print("Schema of remote_media:")
                  cursor.execute("PRAGMA table_info(remote_media)")
                  print(cursor.fetchall())
                  cursor.execute("SELECT * FROM remote_media LIMIT 1")
                  print(cursor.fetchall())
          else:
              print('ERROR: Cache file not found after update!')
          EOF
          
          # Run the script
          python update_cache.py > cache_update.log 2>&1
      
      - name: Setup Cloudflare Tunnel
        run: |
          # Download cloudflared
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          
          # Configure tunnel
          mkdir -p ~/.cloudflared
          echo "${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}" > ~/.cloudflared/tunnel_token
      
      - name: Start WebDAV server in background
        env:
          GP_AUTH_DATA: ${{ secrets.GP_AUTH_DATA }}
        run: |
          echo "Starting WebDAV server..."
          # Restore logging to file to capture errors
          python gphotos_webdav_server.py > webdav.log 2>&1 &
          
          # Wait for server to start
          echo "Waiting for server to initialize..."
          sleep 15
          
          # Check if server started (401 is OK - means server is up but needs auth)
          # Use || true to prevent immediate exit on connection refused
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ || echo "000")
          echo "Server returned HTTP $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… WebDAV server is running (HTTP $HTTP_CODE)"
          else
            echo "âŒ Server failed to start (HTTP $HTTP_CODE)"
            echo "=== WebDAV Log ==="
            cat webdav.log
            exit 1
          fi
      
      - name: Start Cloudflare Tunnel
        run: |
          echo "Starting Cloudflare Tunnel..."
          cloudflared tunnel --no-autoupdate run --token $(cat ~/.cloudflared/tunnel_token) > tunnel.log 2>&1 &
          sleep 10
          
          echo "=========================================="
          echo "ðŸŽ‰ WebDAV Server is now accessible!"
          echo "=========================================="
          echo ""
          echo "Check your Cloudflare Tunnel dashboard for the public URL"
          echo "Or check the public hostname you configured"
          echo ""
          echo "Connection details:"
          echo "  Protocol: WebDAV"
          echo "  Username: user"
          echo "  Password: 12345"
          echo ""
          echo "For VR headsets (Quest, Pico, etc.):"
          echo "  1. Open your video player app"
          echo "  2. Add network storage / WebDAV"
          echo "  3. Enter the Cloudflare URL"
          echo "  4. Use credentials above"
          echo "=========================================="
          
          # Keep workflow running
          echo "Server will run for up to 6 hours or until manually cancelled"
          tail -f webdav.log tunnel.log
